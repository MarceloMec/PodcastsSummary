{"podcast_details": {"podcast_title": "Agile for Humans with Ryan Ripley and Todd Miller", "episode_title": "THE MODERN SOFTWARE DEVELOPER: Pair-programming Battleship", "episode_image": "https://megaphone.imgix.net/podcasts/5924a090-1209-11ee-9040-57d0a300ef17/image/image.jpg?ixlib=rails-4.3.1&max-w=3000&max-h=3000&fit=crop&auto=format,compress", "episode_transcript": " Keep your table sounding like this with Cheerios O'Crunch. It's breakfast bliss that the whole family can enjoy, with energy from whole grains to help keep you going, along with four unique flavors, cinnamon, berry, almond, and oats and honey. So next breakfast, remember, a little crunch goes a long way. Learn more and shop for Cheerios O'Crunch at Cheerios.com. 24 grams to 30 grams whole grain per serving, at least 48 grams recommended daily. This episode is brought to you by Shopify. That's the sound of switching your business to Shopify, the global commerce platform that supercharges your selling. Harness the best converting checkout and same intuitive features, trusted apps, and powerful analytics used by the world's leading brands. Stop leaving sales on the table. Discover why millions trust Shopify to build, grow, and run their business. Sign up today for your $1 per month trial period at Shopify.com slash Tech23. Welcome back to another episode of the Modern Software Developer. My name is Todd Miller. This is Thomas Chessler, both professional Scrum trainer for Scrum.org. What's happening today, Thomas? So I think we will test out how pair programming could look like. And I think you have already a bug in mind in our game that we will apply pair programming, and maybe we can also do TDD. What do you think? I think so. I think I might have found a bug here. If everybody remembers our battleship application that we have a video on, we walked through a little bit in our first episode. Here it is again. And let me remove this so that we can see it. And one thing I noticed, Thomas, I'm not sure if you noticed this either, but we're in the game setup here. We're ready to hit and set up a board. And I just hit enter, and the whole thing shuts up. The whole thing stops. We should fix that. Yeah, that's not a good experience for the user. So I think probably the best way to start this is to write a unit test. What do you think? Yeah, let's probably just quickly identify which thing we should test. So I think it should be probably in the initialize game method. Just click on this initialize game method on line 45 and then hit F12 to go to its definition. And I actually just right clicked and went to go to definition. Yeah, I'm more a keyboard guy. So we have initialized my fleet there. I think that's probably where I would suspect the problem to happen here. And you can start to see the prompts here too. So where we're entering the game position, please enter the positions for the size. You can start to see the prompts here in the console. So I think we're in the right spot. Yeah, and then I think the add position there might be the problem that we would like to identify here. So yeah, I'm going to drill down into that to see. So add position. And so we have a method here that takes an input of string. And it's just checking to see. Well, right now, it's just checking to see if the positions are null, which is a different story here. But how do we then what do you think we do here? Because we want to make sure that this is where I'm thinking is catching it right now. It's trying to translate to a letter and a number. And we're just given an empty. Right. I'm thinking maybe we should test this input here to see if it is empty and prompt the message and say they have to enter something. What do you think? So I think probably that's exactly the point where we should apply a test driven development. So let's first write a test that we can see how it exactly behaves. But that add position method seems exactly the method that we want to test here. So we should probably add a new unit test here calling this method with just an empty string. And then I would expect that it throws this exception that causes our application to crash. So we can then fix the bug and see if the test turns into green. So then we could be quite confident that we fixed at least this scenario. Yes. So that's a solid point. So just kind of taking a timeout from us fixing our bug. Right. When doing test driven development, the idea is to write a failing test first. Right. And so rather than go in and write the solution, what we want to do is we want to call this method as Thomas you have said. And we want to basically have this method throw an exception and then from there we'll go fix it so it doesn't. Right. So we're going to go red, green and hopefully hopefully hopefully we get this right. Yeah. So we probably do some refactoring then because I think that could be potential to to improve this anyway. So I would say that we have already a couple of test projects there. And so we are now currently testing a method in the ship class that we have here in our product. So that's about game controllers and we could either just edit to one of those existing test projects to get quickly started. And then maybe at a later point, we can refactor it to create a new test project for the for the contracts project that we have in there because we don't have one yet. So you're thinking about so we have this battleship game controller tests over here. Yeah, I think that's it. First year. What's that? I'm sorry. Yeah. Let's just edit here and then later we can refactor it to a more proper place. But I agree. Right now we're just looking to see if ship is not valid and ship is valid. We have two different test methods. So I think we want to test here and probably write a test method that says something like I'm just going to do the old copy and paste here. Right. I'm going to I'm going to copy copy the declarator. I think you can copy maybe the whole method because we can probably even reuse some of the logic in there. Yeah, there we go. And then we'll say is how about is what do you want to call it is ship. We could say that. Yeah, or we could say at empty position to ship. Like that. How about an empty ship position. Yeah, because we want to test this very specific scenario. And that's probably one thing that for me is always important about TDD is that you are explicit about a very specific scenario that you're going to test. So we're not caring about anything else that could go wrong when we enter ship positions here. It's just about the empty scenario for now. Yeah, very explicit. We want to say when adding a ship that we're trying to add an empty ship position, just like me hitting enter. So good call out Thomas. Very explicit. And so we realize that the problem exists in this at a position method. Right. It's at a position method. So we got to be able to to be able to call that out a position method. Right. Yeah. So we have already the line where we initialize the ship. So I think we can get rid of line 47. We don't need a position here, but we need the ship. And then we can just call that. I think we don't need the positions there. Just keep it empty. So I think we can remove this part with the positions here. Talking about taking that out. Yeah. And then we can probably add a new line after 47 where we say ship dot add position. And then we just pass an empty string there. That will be exactly what you do on the console. I think the interesting part is now that we should create some clarity about what would be the expected behavior then. What should be the at position method do if the position is not valid? Well, so what I expect is going to happen when we would run this is that it's going to throw an exception. Right. What we would like to do is we'd probably like them to return. So ultimately, in the end, we would probably like it to return a message to the user saying that they cannot input an empty message. Do you agree Thomas? Yeah, I think that would be great. So with that, I think what we could do. Can you quickly switch to the program CS file again where we call this method just to get a bit more clarity? What we could do then is that we return a Boolean value from this at position method that will then indicate if that was the position was successfully added or not. So we can deal printing an output to the user and probably asking to re-enter the position down. I think that's a good idea. So you're suggesting that we change this to a function and return a true or false if the position was added? Yeah, exactly. Then if we validate the position and we see that's an invalid position, we return false and then print a message to the user that that was not a valid position. Okay, but first we still need to make this unit. Well, this unit test will fail because it's going to throw an exception, right? Yeah. So should we try to run it? So yeah, I think we can get rid of line 49. Oh, yep. Yep. Yep. Yep. That's not doing anything for us. Yeah. And the assert should not be true here as well. So we will already throw an exception. That's a good point. So you're thinking in baby steps. That's that's what I'm talking about. Yeah. Because right now we don't have a result. What we want to do is we want this to be some kind of bool, right? We want maybe no, we just expect that it doesn't throw an exception, right? So that's probably our first step. So switching this to returning a bool would be already our first implementation to fix the bug. So let's get just rid of the assert. So just remove line. And you're suggesting, yeah, let's get the throw the exception because this should not accept. Yeah. And if you run the test, it will result in a red test, I would say. And we're running. Yeah. Let's go to the test. Oh, yeah. There is the red test. OK. And that's what we want. Yeah. So that's the strange thing about GDD. So you're happy if you have a red test, right? Yeah. To start. To start. So we have a red test. We've we've and the idea with this is this is actually just this is just explicitly throwing an exception, right? This is just fundamentally not working because we haven't implemented what you've insinuated, which is to return a boolean. So now the step would be let's go change that method into a function and return a true or false. Sound good? Yeah. Yeah. That's all. And then we'll come back and update our test after that. So we have a red test. We have a test that's failing. We're going to come back in here and we want to change this into from a method to a boolean. So bool. Not returning anything yet. So we want to be able to add a true. So how would we what would you say? Should we just test the string input? We have positions knowledge. Should we just do an if here? You think and look at the input? I think what we can do probably as a first step, just say return true at the end of this method. Yeah, that way we get rid of the red. Yeah. Yeah. It will still be red because it's still be throw throwing an exception. But then that will enable us to add an assertion to our test, I would say. So if you can switch to the test again. Gotcha. Now we can say just say maybe something like var actual equals ship at position so that we get the boolean there. But where do you want to call this? Var. I usually call it actual. It's the actual result of this. But it's just how I do it. So it's like that actual is pretty good. It makes sense. But now we're still going to get an exception here because we're adding an empty position. So we're still going to be red. I'm going to run it again just just to show. Yeah. So they're going to be red. So but that would be oh sorry sorry I'm wrong. It should not be true in this case. It should be false. The actual assertion should be is false. Oh yes that's actually yeah yeah because when they put the empty and we want it to return false. We want it to return false. Yeah. Yeah. Yeah. Gotcha. So and then we can now change our implementation to turn this test finally into a red one. We could easily say if input if string dot is empty input. I think that's the proper way in C sharp string is not empty I think. Yeah. I guess you should get a green light after this Thomas. I hope so. Let's see. It just will tell us. So I'm just coming. I like to I always like to when I'm specifically another. This is me. I think we all fall into habits. But when I'm specifically writing a unit test I just come in like to instantiate it from here when I'm looking at it because it helps me to think about it. The logic that I wrote is is is is going to solve the problem. So I'm just going to run tests. I like to run tests from here. I feel like we all have our own habits. Do you have the same thing. When we were about to show your visual studio we're going to see the background as white and mine. I like the dark background. Everybody has their own preferences on how they do things. And the thing that I find really cool about pair programming is like a thing like actual it seems really small like you really like a result for their actual. For where the ship position is. I like that but I don't do it that way. But maybe I will now which makes a more cohesive code base like we're learning together we're also working together right. Absolutely. Do you buy the way our test worked. Yeah. Cool. By the way do you know about the life unit test feature that comes with some versions of visual studio. I do not tell me that. So that's really awesome. So you can let visual studio run your unit test in the background while you're writing the code. So you are changing the code here and it shows you after a second or so that this code that you have that you're actually seeing is making your test pass so you don't have to execute you don't have to trigger your test. It's done by which the studio automatically in the background. And you know I think that's a brilliant because so many times we run into CI builds that go too long because the tests are not as small as this like these are really small tests. And when it goes through your continuous integration build these should give a really quick response easy feedback to you right. That's the idea. Your continuous integration build shouldn't be something that takes a long time to run. And I think that by having it within visual studio given system limitations that if you're getting that immediate feedback that you're probably writing your unit test really nice and discrete like you were talking about before Thomas. Yeah. And especially for TDD where you execute your unit test frequently. That's a really nice feature. I really like it. Okay. But yeah we have a green test. So that means that at least our at precision method now can nicely handle this empty positions and we could then just update our program CS to see okay is this returning a false then we should have to do to re enter the position because it's invalid. Probably I think we can ignore this integration in the UI for now because we want to focus on the TDD part. I think we can probably then just think about maybe the empty position is not the only issue that we are having here. Yeah you know what I'm thinking about doing though Thomas I think I'm going to check this in. I think I'm going to push some changes to get and why don't you pull them down. How's that sounds. Sure, let's do that. So, I'm going to say fixed empty position. Bug. I know we should probably have a bit better of a message than that but I'm going to, I'm going to, I'm going to check this in and push it your way. Okay. Okay, so I guess when you pushed. Let me do pull. All right. And whenever you're ready I think what I'm going to do is I'm going to remove my myself from the screen. And I'm going to add your version of Visual Studio you ready for that. Yeah, let's go. So I have the version here. Oh, you know what today. Maybe just rebuild it. Yeah. Okay, we will all succeeded. And I think what we can do here now is, what do you think what do you have a suspicion what else could cause some problems with the positions we are entering here. You know it's interesting because when I was noticing when we were when we were modifying that when we change that app position method into a function and made it a Boolean, one thing I noticed is that it's really keying off those enums to devise a position. And we are boards limited right, our board doesn't have a z position for instance, right, it doesn't have. And so when it goes to convert that enum, if we were to enter something outside the bounds of an actual position if we were to enter a z, which is outside the bounds of the board. I think it would fail. What do you think. I don't know what, so easiest way would be to write a unit test I'm not sure why my wish is to you will underline this thing here, but yeah. So, I mean just see if I can start a live unit test session here. Let's finish this let's see if I can get this running here. And that should be your assumption that should give us a red unit test again, because if we add a position outside of the board, then it will return false but actually currently it does throw an exception. So that's now how you see the indication of our live unit test so you see there are those red X's next to my code that tells me that this, while executing this code this test method. It discovered a red test case. And so I don't have to execute the test cases manually. So, that's really great feature. Yeah, I like it. So let's, with that, go into our ad position. What would you propose how we could fix that. It seems like a really easy solution to just check for Z but I don't think that's a permanent long term one. I think that something that would be good for us to do here is to check to see if, if there is an alpha numeric that is outside the bounds of an enum, and then return false if that's the case, what do you think about that. Yeah, so I think we already have here the input with a substring. We have the substring here. So I think we can probably just refactor this out of this long, even long line here, and then having this as a string so we can check the string before we put it into the parser. I think that's a great idea. Check the string. And then if it's outside the bounds of an enum, we put it in the parser that way we're covering lots of edge cases because I think that we could write another unit test for why or anything outside the bounds of the board, right, so I wonder if we could, if we could make it, that it would that it would fit. Will you for our first implementation be okay if we just assume a static size for our board. So I know currently in our game. The positions can be from A to H. I'll check, is it smaller than A or is it bigger than H. And I think it will be a little bit more complicated to see okay if it's in the bounds of the, you know. Yeah, I think I think it might be, I think it might be a great idea to check to see if, if it's in the bounds that you described I think that we're going to have a fixed board size for this game for right now anyway, I don't see why we wouldn't want to make it that. I think we can do it easy comparison with lower than and bigger than if it's a character. So, so if it's lower than a. That should work. So, I'm at the same thing and greater than type string to char is doing it the blind way we have to refactor step in our TDD cycle so let me just get it working quickly and then we can discuss how we will probably refactor this code to make it look a little bit nicer because I'm not really happy with it how it looks like. Yeah. That's actually a good point. Okay, so if the letter of the string is lower than a or greater than age, then we should return a false. And then we have just to pass the letter string in here to our parse method. And look at that, our test is green. I love that I love that live testing feature. How fantastic is that and I think that it's just a reminder to write your test small, or you can't do this, or you won't be right it would take too long, everything would be quite slow. So, yeah. Awesome. Yeah, so we have a green test so let's see what we should reflect to here. Yeah, so it's interesting let's suppose then Thomas that we come back to this and we have to add functionality to this in two months. How much safer does it feel when we see this we go oh wow Thomas we did not write this the way that we thought we should write this two months ago. How much safer do you feel refactoring it right now knowing that this is where we're, we're, we have a test behind this, making sure that it's within the balance of the board. Yeah, and I think that is exactly the definition of refactoring it's improving your code without changing its behavior. Or in other words, you could say, we are changing the code without breaking the existing unit test that is what I would call refactoring. Yeah, and I think you're absolutely right here that this unit test already gives us way more safety for future changes. But I find it always an interesting question but for probably refactoring is another topic we will discuss in one of the upcoming episodes but you're right, you just should be refactored just right away when we are already in the context, or will we refactor this a little bit later and that's what the TDD cycle implies that once you have written a functionality, once you are in the context of the test, try to improve it. Make it better right on the spot. Yeah, yeah. And I think we have an opportunity to do this for this one. What do you think of, what do you think the best way to handle this is I threw out one idea where I thought we could potentially have a list of things that are outside the bounds of the board but that might be a little bit rough around the edges. Yeah, I think what we can obviously do at some point is to make those A and H more dynamic, probably we even want to pass this in, but it's probably not required yet. So, I think what we could first do is that we can, let's just see if that works if I remove this to chart, can't I in C sharp just use an index on a string. Yeah, that seems to compile and to test is still green so it seems it has exactly the same behavior than what we had before. You got a little bit of ugly out of there right. I want to just apply the boy scout rule to say okay let's make it a little bit better, it's probably not have to, to be perfect. And for me it's always finding a good balance to really make progress and not to waste too much time to make this perfect. And as Jeff mentioned we have to safety net with our unit test to reflect it is at any point. Yes, yeah if we come back, maybe three years from now and see sharp implemented something newer when it comes to looking at strings right maybe we could use that here or if we, if this is good for us for now and it looks good and it's the best that we can do we now refactor it looks cleaner than it did before. Then, then, then we can move on right because it inevitably we're going to come back into this, this, this, this function at add position, and as we expand the game and make the game more robust. This is going to change. And so I feel pretty safe about the fact now that we're not going to let empty strings or invalid character positions and. And obviously another refactoring I would propose is now start moving out the, the tests that we have created here into a separate test project, just to have a clean structure. And I think that's a good start, but I think probably we are not going to record this on the video because we are already talking for quite a long time, just like a couple of minutes but if I look at a timer so it's already a long time. So I think we have this one requirement on our backlog that we want to have configurable size for the board of the game then we will probably come back and fix that, but I'm also a big fan of the acne principles so you ain't gonna get going to need it. Let's not build something that we are not currently needing so let's build it when there is a demand for this functionality. So that can be in a later point in time. Yeah, build it build it for today, not for every single circumstance that you can possibly think of. And so we would have just to finish this up we obviously would also check the, the rows the numbers that they are all also in between one to eight. And that will be another test that we would add and then extend our implementation then obviously we should not forget about handling the return of the Boolean value in our programs yes in our UI. That will be something that we could just keep up for outside of this video. Yeah, yeah, I'm going to pull this back in here yeah I think that would be something good for the next time that we get together is maybe we can show like a finish finishing move on it to use a little bit of Mortal Kombat style stuff. But I think, unlike you I think I'd be tempted as we start to extend that to probably reorganize and make those unit tests in their own class right just for just for the cleanliness of it but for it now. We're taking good input from the, from the user we're not taking anything outside the bounds of it. Thomas unless you have anything to say I think that maybe we'll go end screen. Oddly enough this wasn't Thomas and I's first time pairing together we've paired together several times in the past. I'm going to bring up the end screen. So if you're finding use in these videos the modern software developer this is an experiment that Thomas and I are really trying we're very passionate about it. If you have any ideas you'd like to see let us know what you think of these videos, I'm sure that you coders out there probably thinking of new and greater things and different ways that we, we could have done that. That's all the stuff we like. But what else do you want to hear about what else do you want to see what other points of debate you have, make sure to like and subscribe for the Admin for Humans Network. Yeah, we'll keep these videos coming. So it's me, Todd Miller, and for Thomas Schistler. Thank you all. Hey it's Ryan, if you're enjoying this show and want to take a deeper dive into scrum with me and check out agile for humans.com forward slash training. Be sure to also look at the show notes to subscribe to our newsletter, get a copy of our book fixing your scrum and learn more about working with us at agile for humans. Thanks for listening and scrum on."}, "podcast_summary": "In this episode of \"The Modern Software Developer\" podcast, Todd Miller and Thomas Chessler, professional Scrum trainers from Scrum.org, discuss the implementation of pair programming and test-driven development (TDD) in their game development project. They encounter a bug in their game setup where hitting enter crashes the game, and they decide to use TDD to fix it. They start by writing a failing unit test for the bug and then refactor their code to make the test pass. They add checks to ensure that an empty position and positions outside the bounds of the game board are not accepted. They also discuss the importance of refactoring and the benefits of having unit tests for safety and future changes. The episode ends with a plan to continue extending the game and handling user input properly.", "podcast_guest": "Thomas Chessler", "podcast_highlights": "In this podcast episode of \"The Modern Software Developer,\" Todd Miller and Thomas Chessler discuss pair programming and test-driven development (TDD). They identify a bug in their game application and demonstrate how to write a failing test first. They then refactor the code to fix the bug and make it pass the test. They also discuss the importance of writing explicit tests and the benefits of using TDD to improve code quality and maintainability. \n\nHighlights:\n- Identifying a bug in the game setup \n- Writing a failing test for the bug \n- Changing the code to fix the bug and make the test pass \n- Discussing the benefits of pair programming and TDD \n- Refactoring the code for better readability \n- Planning future improvements and enhancements for the game application."}